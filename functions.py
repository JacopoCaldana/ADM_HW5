# -*- coding: utf-8 -*-
"""functions.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-2GKQXA1p4wV0pwMEJcQ1IXLmUX2LBbv
"""

import matplotlib.pyplot as plt
import networkx as nx
import itertools
import random

def manual_in_out_degrees(graph):
    in_degrees = {}
    out_degrees = {}

    for node, destinations in graph.items():
        # Update out-degree
        out_degrees[node] = out_degrees.get(node, 0) + len(destinations)
        
        # Update in-degrees for all destinations
        for dest in destinations:
            in_degrees[dest] = in_degrees.get(dest, 0) + 1
            if dest not in out_degrees:
                out_degrees[dest] = 0  # Ensure all nodes appear in out-degrees
    
    # Ensure all nodes appear in in-degrees
    for node in graph:
        if node not in in_degrees:
            in_degrees[node] = 0

    return in_degrees, out_degrees

def visualize_graph(graph,title,edge_color='black',node_color='lightblue',highlighted_edges=None):
    plt.figure(figsize=(12,8))
    pos=nx.spring_layout(graph)
    nx.draw(graph,pos,with_labels=True,node_color=node_color,edge_color=edge_color,node_size=700,font_size=8)
    if highlighted_edges:
        nx.draw_networkx_edges(graph,pos,edgelist=highlighted_edges,edge_color='red',width=2)
    plt.title(title)
    plt.show()
def MinCut(graph):
    import itertools
    #list of all edges
    edges=list(graph.edges())
    #verify all combination of edges to find the minimum number of edges to remove
    for i in range(1,len(edges)+1):
        for edge_combination in itertools.combinations(edges,i):
            app=graph.copy()
            app.remove_edges_from(edge_combination)
            if not nx.is_connected(app):
                return list(edge_combination)
    return []
def visualize_communities(graph,communities,title):
    plt.figure(figsize=(12, 8))
    pos=nx.spring_layout(graph)
    #assign a color for each communities
    community_colors={}
    for i in range(len(communities)):
        community_colors[i]=random.choice(plt.cm.tab20.colors)
    #assign colors to nodes based communities
    node_colors=[]
    for node in graph:
        for i in range(len(communities)):
            if node in communities[i]:
                node_colors.append(community_colors[i])
                break
    #draw graph
    nx.draw(graph,pos,node_color=node_colors,with_labels=True,node_size=500,font_size=8)
    plt.title(title)
    plt.show()

def girvan_newman(graph,target_communities=2):
    graph_copy=graph.copy()
    communities=list(nx.connected_components(graph_copy))
    while len(communities)<target_communities:
    #calculate betweenness centrality and remove the edge with the highest betweenness centrality value
        edge=max(nx.edge_betweenness_centrality(graph_copy), key=nx.edge_betweenness_centrality(graph_copy).get)
        u, v=edge
        graph_copy.remove_edge(u,v)
        communities=list(nx.connected_components(graph_copy))
    return communities

def are_in_same_community(city1,city2,communities):
    for i in communities:
        if city1 in i and city2 in i:
            return True
        else:
            return False
